<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java时间格式化</title>
      <link href="/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91/Java%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91/Java%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-String-format"><a href="#1-String-format" class="headerlink" title="1.String.format()"></a>1.String.format()</h2><p>format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。</p><p>format(Locale locale, String format, Object… args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。</p><h3 id="1-1-日期格式化"><a href="#1-1-日期格式化" class="headerlink" title="1.1 日期格式化"></a><strong>1.1 日期格式化</strong></h3><p>常用的日期转换格式符</p><table border="1" cellpadding="1" cellspacing="5"><thead><tr><th>转换符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%te</td><td>一个月中的某一天（1~31）</td><td>10</td></tr><tr><td>%td</td><td>一个月中的第几天（1~31）</td><td>03</td></tr><tr><td>%tj</td><td>一年中的第几天（1~366）</td><td>020</td></tr><tr><td>%tb</td><td>指定语言环境的月份简称</td><td>Feb（英文）、二月（中文）</td></tr><tr><td>%tB</td><td>指定语言环境的月份全称</td><td>February（英文）、二月（中文）</td></tr><tr><td>%ta</td><td>指定语言环境的星期简称</td><td>Mon（英文）、星期一（中文）</td></tr><tr><td>%tA</td><td>指定语言环境的星期全称</td><td>Monday（星期一）、星期一（中文）</td></tr><tr><td>%tc</td><td>包括全部日期和时间信息</td><td>星期六&nbsp; 六月&nbsp; 10&nbsp; 09:10:20 CST 2023</td></tr><tr><td>%tY</td><td>4 位年份</td><td>2023</td></tr><tr><td>%ty</td><td>2 位年份</td><td>23</td></tr><tr><td>%tm</td><td>月份</td><td>05</td></tr></tbody></table><p> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">         <span class="type">String</span> <span class="variable">day</span> <span class="operator">=</span> String.format(<span class="string">&quot;%te&quot;</span>, date);</span><br><span class="line">         System.out.println(<span class="string">&quot;今天是2019年8月：&quot;</span> + day + <span class="string">&quot;号&quot;</span>);</span><br><span class="line">         <span class="type">String</span> <span class="variable">month</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tb&quot;</span>, date);</span><br><span class="line">         System.out.println(<span class="string">&quot;现在是2019年：&quot;</span> + month);</span><br><span class="line">         <span class="type">String</span> <span class="variable">xingqi</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tA&quot;</span>, date);</span><br><span class="line">         System.out.println(<span class="string">&quot;今天是：&quot;</span> + xingqi);</span><br><span class="line">        <span class="type">String</span> <span class="variable">year</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tY&quot;</span>, date);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在是：&quot;</span> + year + <span class="string">&quot;年&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">30号</span><br><span class="line">十月</span><br><span class="line">今天是：星期三</span><br><span class="line">现在是：2024年</span><br></pre></td></tr></table></figure><h3 id="1-2-时间格式化"><a href="#1-2-时间格式化" class="headerlink" title="1.2 时间格式化"></a>1.2 时间格式化</h3><p>常用的时间格式转换符</p><table border="1" cellpadding="1" cellspacing="2"><thead><tr><th>转换符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%tH</td><td>2 位数字的 24 时制的小时（00~23）</td><td>13</td></tr><tr><td>%tI</td><td>2 位数字的 12 时制的小时（00~23）</td><td>01</td></tr><tr><td>%tM</td><td>2 位数字的分钟（00~59）</td><td>05</td></tr><tr><td>%tS</td><td>2 位数字的秒数（00~60）</td><td>12</td></tr><tr><td>%tL</td><td>3 位数字的毫秒（000~999）</td><td>666</td></tr><tr><td>%tp</td><td>指定语言环境下的上午或下午标记</td><td>下午（中文）、pm（英文）</td></tr><tr><td>%tZ</td><td>时区缩写形式的字符串</td><td><p>CST</p></td></tr></tbody></table><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hour</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tH&quot;</span>, date);</span><br><span class="line">        <span class="type">String</span> <span class="variable">minute</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tM&quot;</span>, date);</span><br><span class="line">        <span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tS&quot;</span>, date);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在是：&quot;</span> + hour + <span class="string">&quot;点&quot;</span> + minute + <span class="string">&quot;分&quot;</span> + second + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;##################################&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hour2</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tI&quot;</span>, date);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pm</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tp&quot;</span>, date);</span><br><span class="line">        System.out.println(<span class="string">&quot;现在是：&quot;</span> + pm + hour2 + <span class="string">&quot;点&quot;</span> + minute + <span class="string">&quot;分&quot;</span> + second + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在是：<span class="number">15</span>点<span class="number">59</span>分<span class="number">05</span>秒</span><br><span class="line">##################################</span><br><span class="line">现在是：下午<span class="number">03</span>点<span class="number">59</span>分<span class="number">05</span>秒</span><br></pre></td></tr></table></figure><h3 id="1-3-常见的日期和时间组合的格式"><a href="#1-3-常见的日期和时间组合的格式" class="headerlink" title="1.3 常见的日期和时间组合的格式"></a>1.3 常见的日期和时间组合的格式</h3><table border="1" cellpadding="1" cellspacing="2"><thead><tr><th>转换符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>%tF</td><td>"年 - 月 - 日" 格式</td><td>2021-05-09</td></tr><tr><td>%tD</td><td>"月 / 日 / 年" 格式</td><td>05/09/2021</td></tr><tr><td>%tT</td><td>"时：分：秒" 24 时制</td><td>08:20:42</td></tr><tr><td>%tR</td><td>"时：分" 24 时制</td><td><p>08:20</p></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">         <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tc&quot;</span>, date);</span><br><span class="line">         <span class="type">String</span> <span class="variable">form</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tF&quot;</span>, date);</span><br><span class="line">         <span class="type">String</span> <span class="variable">form2</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tD&quot;</span>, date);</span><br><span class="line">         <span class="type">String</span> <span class="variable">form3</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tr&quot;</span>, date);</span><br><span class="line">         <span class="type">String</span> <span class="variable">form4</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tT&quot;</span>, date);</span><br><span class="line">         <span class="type">String</span> <span class="variable">form5</span> <span class="operator">=</span> String.format(<span class="string">&quot;%tR&quot;</span>, date);</span><br><span class="line">         System.out.println(<span class="string">&quot;全部的时间信息是：&quot;</span> + time);</span><br><span class="line">         System.out.println(<span class="string">&quot;年-月-日格式：&quot;</span> + form);</span><br><span class="line">         System.out.println(<span class="string">&quot;年/月/日格式：&quot;</span> + form2);</span><br><span class="line">         System.out.println(<span class="string">&quot;时：分：秒 PM(AM)格式：&quot;</span> + form3);</span><br><span class="line">         System.out.println(<span class="string">&quot;时：分：秒格式：&quot;</span> + form4);</span><br><span class="line">         System.out.println(<span class="string">&quot;时：分格式：&quot;</span> + form5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全部的时间信息是：星期三 十月 30 16:00:32 CST 2024</span><br><span class="line">年-月-日格式：2024-10-30</span><br><span class="line">年/月/日格式：10/30/24</span><br><span class="line">时：分：秒 PM(AM)格式：04:00:32 下午</span><br><span class="line">时：分：秒格式：16:00:32</span><br><span class="line">时：分格式：16:00</span><br></pre></td></tr></table></figure><h2 id="2-DateFormat"><a href="#2-DateFormat" class="headerlink" title="2.DateFormat "></a>2.DateFormat </h2><p>DateFormat 是日期 &#x2F; 时间格式化的抽象类，它以与语言无关的方式格式化并分析日期或时间。DataFormat 还有一个子类 —— SimpleDateFormat，可用此类格式化日期。其中，最常用的方法是 format() 方法。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日  HH时mm分&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日  HH时mm分ss秒&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今年已经过了DDD天，快w个星期，现在是这个月的第W个星期&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;现在是E&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1</span> <span class="operator">=</span> sdf1.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2</span> <span class="operator">=</span> sdf2.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">date3</span> <span class="operator">=</span> sdf3.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">date4</span> <span class="operator">=</span> sdf4.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">date5</span> <span class="operator">=</span> sdf5.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">date6</span> <span class="operator">=</span> sdf6.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(date1);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">        System.out.println(date3);</span><br><span class="line">        System.out.println(date4);</span><br><span class="line">        System.out.println(date5);</span><br><span class="line">        System.out.println(date6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">24年10月30日</span><br><span class="line">2024年10月30日</span><br><span class="line">2024年10月30日  16时01分</span><br><span class="line">2024年10月30日  16时01分35秒</span><br><span class="line">今年已经过了304天，快44个星期，现在是这个月的第5个星期</span><br><span class="line">现在是星期三</span><br></pre></td></tr></table></figure><h2 id="3-SimpleDateFormat-类"><a href="#3-SimpleDateFormat-类" class="headerlink" title=" 3.SimpleDateFormat 类"></a> 3.SimpleDateFormat 类</h2><p>        在使用 DateFormat 类时，只有固定格式，在 java.text.SimpleDateFormat 包有一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。 SimpleDateFormat 使得可以选择任何用户定义的日期 - 时间格式的模式。</p><p><strong>SimpleDateFormat 类基本构造方法：</strong></p><p>SimpleDateFormat 类是 DateFormat 类的一个子类。</p><ul><li>new SimpleDateFormat(); 默认模式和默认日期格式符号创造。</li><li>SimpleDateFormat(String pattern); 使用指定的模式和默认日期格式符号创造。</li><li>SimpleDateFormat(String pattern, Locale locale); 使用指定的模式和指定语言环境的默认日期符号构造。</li></ul><p>DateFormat 也可以 new SimpleDateFormat 对象。</p><blockquote><p>DateFormat d&#x3D;new SimpleDateFormat();</p></blockquote><p><strong>代表日期和时间的模式元素字母：</strong></p><table><thead><tr><th>字母</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>y</td><td>年，一个 y 代表一位</td><td>"yyy" 代表 019，"yyyy" 代表 2019</td></tr><tr><td>M</td><td>月份</td><td>例如八月，M 代表 8，MM 代表 08</td></tr><tr><td>w</td><td>一年中的第几周</td><td>常用 ww 表示</td></tr><tr><td>W</td><td>一个月中的第几周</td><td>常用 WW 表示</td></tr><tr><td>d</td><td>一个月中的第几天</td><td>常用 dd 表示</td></tr><tr><td>D</td><td>一年中的第几天</td><td>常用 DDD 表示</td></tr><tr><td>E</td><td>星期几，用 E 表示星期，根据不同语言环境返回</td><td>CHINA 表示星期几，US 表示英文缩写</td></tr><tr><td>a</td><td>上午或下午</td><td>am 代表上午，pm 代表下午</td></tr><tr><td>H</td><td>一天中的小时数，二十四小时制</td><td>常用 HH 表示</td></tr><tr><td>h</td><td>一天中的小时数，十二小时制</td><td>常用 hh 表示</td></tr><tr><td>m</td><td>分钟数</td><td>常用 mm 表示</td></tr><tr><td>s</td><td>秒数</td><td>常用 ss 表示</td></tr><tr><td>S</td><td>毫秒数</td><td>常用 SSS 表示</td></tr></tbody></table><p> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormatDateTime</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SimpleDateFormat myFmt=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        SimpleDateFormat myFmt1=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yy/MM/dd HH:mm&quot;</span>); </span><br><span class="line">        SimpleDateFormat myFmt2=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="comment">//等价于now.toLocaleString()</span></span><br><span class="line">        SimpleDateFormat myFmt3=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 E &quot;</span>);</span><br><span class="line">        SimpleDateFormat myFmt4=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(</span><br><span class="line">                <span class="string">&quot;一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区&quot;</span>);</span><br><span class="line">        Date now=<span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 现在的日期</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照自定义的时间编排格式 输出时间</span></span><br><span class="line">        System.out.println(myFmt.format(now));</span><br><span class="line">        System.out.println(myFmt1.format(now));</span><br><span class="line">        System.out.println(myFmt2.format(now));</span><br><span class="line">        System.out.println(myFmt3.format(now));</span><br><span class="line">        System.out.println(myFmt4.format(now));</span><br><span class="line">        System.out.println(now.toGMTString());</span><br><span class="line">        System.out.println(now.toLocaleString());</span><br><span class="line">        System.out.println(now.toString());</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2024年10月30日 16时02分43秒</span><br><span class="line">24/10/30 16:02</span><br><span class="line">2024-10-30 16:02:43</span><br><span class="line">2024年10月30日 16时02分43秒 星期三 </span><br><span class="line">一年中的第 304 天 一年中第44个星期 一月中第5个星期 在一天中16时 CST时区</span><br><span class="line">30 Oct 2024 08:02:43 GMT</span><br><span class="line">2024-10-30 16:02:43</span><br><span class="line">Wed Oct 30 16:02:43 CST 2024</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/8b30e9335630cd6ea0fec1ec2aec744f.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实际开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实际开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间戳介绍</title>
      <link href="/%E5%B8%B8%E8%AF%86/%E6%97%B6%E9%97%B4%E6%88%B3%E4%BB%8B%E7%BB%8D/"/>
      <url>/%E5%B8%B8%E8%AF%86/%E6%97%B6%E9%97%B4%E6%88%B3%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>        时间戳（Timestamp）是表示特定时间点的数值，通常以自 1970 年 1 月 1 日 00:00:00 UTC （世界协调时）以来的秒数或毫秒数来表示。这个时间点被称为 Unix 纪元（Unix epoch）。时间戳广泛用于计算机系统中，用于记录事件发生的精确时间。</p><h2 id="时间戳的格式"><a href="#时间戳的格式" class="headerlink" title="时间戳的格式"></a>时间戳的格式</h2><p>时间戳通常是一个整数或浮点数，例如：</p><ul><li>Unix 时间戳（秒级）： 1622548800</li><li>Unix 时间戳（毫秒级）： 1622548800123</li></ul><h2 id="时间戳的用途"><a href="#时间戳的用途" class="headerlink" title="时间戳的用途"></a>时间戳的用途</h2><ol><li><strong>记录日志</strong>：在日志文件中使用时间戳可以精确记录事件发生的时间，方便日后分析和调试。</li><li><strong>数据库记录</strong>：在数据库中使用时间戳可以追踪记录的创建和更新时间。</li><li><strong>时间计算</strong>：通过时间戳可以方便地进行时间差的计算，例如测量程序执行时间、计算事件间隔等。</li><li><strong>排序</strong>：使用时间戳可以对事件按时间顺序进行排序。</li></ol><h2 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h2><p>以下是一些常见编程语言中如何使用时间戳的示例： </p><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间的时间戳（秒级）</span></span><br><span class="line"><span class="keyword">const</span> timestampInSeconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取当前时间的时间戳（毫秒级）</span></span><br><span class="line"><span class="keyword">const</span> timestampInMilliseconds = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将时间戳转换为日期对象</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(timestampInMilliseconds);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toString</span>());</span><br></pre></td></tr></table></figure><p> Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取当前时间的时间戳（秒级）</span></span><br><span class="line">timestamp_in_seconds = <span class="built_in">int</span>(time.time())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取当前时间的时间戳（毫秒级）</span></span><br><span class="line">timestamp_in_milliseconds = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将时间戳转换为日期时间对象</span></span><br><span class="line">date = datetime.datetime.fromtimestamp(timestamp_in_seconds)</span><br><span class="line"><span class="built_in">print</span>(date.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span><br></pre></td></tr></table></figure><p>Java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间的时间戳（秒级）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestampInSeconds</span> <span class="operator">=</span> Instant.now().getEpochSecond();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取当前时间的时间戳（毫秒级）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestampInMilliseconds</span> <span class="operator">=</span> Instant.now().toEpochMilli();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将时间戳转换为日期时间对象</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(timestampInMilliseconds), ZoneId.systemDefault());</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(dateTime.format(formatter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>         这些例子展示了如何获取当前时间的时间戳，如何将<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">时间戳转换</a>为日期时间对象，并输出为人类可读的格式。时间戳在编程中是非常有用的工具，能够精确记录和处理时间相关的信息。</p><p>以下是一些适合中国用户使用的在线时间戳转换工具：</p><ol><li><p>时间戳转换工具<br>地址：<a href="https://tool.lu/timestamp/" title="[tool.lu/timestamp/]">[tool.lu&#x2F;timestamp&#x2F;]</a><br>   描述：一个简单易用的时间戳转换工具，支持将时间戳转换为北京时间，以及将北京时间转换为时间戳。</p></li><li><p>在线工具 - Unix 时间戳转换<br>地址：<a href="https://www.bejson.com/convert/unix/" title="[bejson.com/convert/unix/]">[bejson.com&#x2F;convert&#x2F;unix&#x2F;]</a><br>   描述：提供 Unix 时间戳与北京时间的相互转换。</p></li><li><p>菜鸟工具 - Unix 时间戳<br>地址：<a href="https://c.runoob.com/front-end/854" title="[c.runoob.com/front-end/854]">[c.runoob.com&#x2F;front-end&#x2F;854]</a><br>   描述：支持 Unix 时间戳与标准时间的转换。</p></li></ol><p>这些工具都提供了简洁易用的界面，可以方便地进行时间戳与北京时间的相互转换。你可以选择一个适合自己的工具进行使用。</p>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间格式化-前后端交互- @JsonFormat 和 @DateTimeFormat</title>
      <link href="/Spring/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92-JsonFormat-%E5%92%8C-DateTimeFormat/"/>
      <url>/Spring/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92-JsonFormat-%E5%92%8C-DateTimeFormat/</url>
      
        <content type="html"><![CDATA[<h1 id="时间格式化-JsonFormat-和-DateTimeFormat"><a href="#时间格式化-JsonFormat-和-DateTimeFormat" class="headerlink" title="时间格式化 @JsonFormat 和 @DateTimeFormat"></a>时间格式化 @JsonFormat 和 @DateTimeFormat</h1><h3 id="一、示例代码"><a href="#一、示例代码" class="headerlink" title="一、示例代码"></a>一、示例代码</h3><ul><li>先准备一个简单 POJO，拥有 Date 类型的成员变量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再准备一个 Controller，模拟一下前后交互：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DateEntity <span class="title function_">getDate</span><span class="params">(<span class="meta">@RequestBody</span> DateEntity dateEntity)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;入参的date:&quot;</span>+dateEntity.getDate());</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> sdf.format(dateEntity.getDate());</span><br><span class="line">        System.out.println(<span class="string">&quot;SimpleDateFormat格式化后的date:&quot;</span>+date);</span><br><span class="line"></span><br><span class="line">        <span class="type">DateEntity</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateEntity</span>();</span><br><span class="line">        result.setDate(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建好 POJO 和 Controller 后，用 Postman 模拟一下请求发送：  </p></li><li><p>结果报错：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2024-10-14 16:00:29.159  WARN 23616 --- [nio-8080-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.util.Date` from String &quot;2025-03-07 23:59:59&quot;: not a valid representation (error: Failed to parse Date value &#x27;2025-03-07 23:59:59&#x27;: Cannot parse date &quot;2025-03-07 23:59:59&quot;: while it seems to fit format &#x27;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSX&#x27;, parsing fails (leniency? null)); nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type `java.util.Date` from String &quot;2025-03-07 23:59:59&quot;: not a valid representation (error: Failed to parse Date value &#x27;2025-03-07 23:59:59&#x27;: Cannot parse date &quot;2025-03-07 23:59:59&quot;: while it seems to fit format &#x27;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSX&#x27;, parsing fails (leniency? null))&lt;EOL&gt; at [Source: (org.springframework.util.StreamUtils$NonClosingInputStream); line: 2, column: 12] (through reference chain: com.saikuai.pojo.DateTest[&quot;date&quot;])]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>大概意思就是说 String 类型转换成 Date 类型失败，所以报了 IllegalArgumentException 异常；</p></li></ul><h3 id="二、-JsonFormat-注解"><a href="#二、-JsonFormat-注解" class="headerlink" title="二、@JsonFormat 注解"></a>二、@JsonFormat 注解</h3><ul><li>提供者：jackson</li><li>作用：可以约束时间的<strong>接收格式</strong>和<strong>响应格式</strong> (接收和响应的都是 <strong>JSON 字符串</strong>)，将日期类型数据在 JSON 格式和 java.util.Date 对象之间转换。与传输方向没有关系（前端到后端 or 后端到前端都可以使用），<strong>注意</strong>因为我们是东八区（北京时间），使用时需要加上时区（ timezone &#x3D; “GMT+8”），<strong>不然所得值会比实际时间晚 8 小时</strong>；</li><li>常用注解属性：</li></ul><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>pattern</td><td>约定时间格式：pattern=“yyyy-MM-dd HH:mm:ss”</td></tr><tr><td>timezone</td><td>指定具体时区： timezone = “GMT+8” or timezone = “Asia/Shanghai”</td></tr></tbody></table><ul><li>经过测试使用<strong>单独使用</strong> @JsonFormat 注解时需要先通过 @RequestBody 将入参参数映射到实体后，@JsonFormat 注解才能去对时间格式进行约束；</li><li>POJO 类中也加上了 @JsonFormat 注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateEntity</span> &#123;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd hh&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>测试：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DateTest(date=Fri Mar <span class="number">07</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span> CST <span class="number">2025</span>, name=<span class="literal">null</span>, age=<span class="literal">null</span>)</span><br><span class="line">入参的date:Fri Mar <span class="number">07</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span> CST <span class="number">2025</span></span><br><span class="line">SimpleDateFormat格式化后的date:<span class="number">2025</span>-<span class="number">03</span>-<span class="number">07</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">  </span><br><span class="line">--  </span><br><span class="line">  responsebody：</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="string">&quot;date&quot;</span>: <span class="string">&quot;2024-10-14 16:07:38&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 对前端入参和 后段出参都做了约束</p></li></ul><h3 id="三、-DateTimeFormat-注解"><a href="#三、-DateTimeFormat-注解" class="headerlink" title="三、@DateTimeFormat 注解"></a>三、@DateTimeFormat 注解</h3><ul><li>提供者：Spring</li><li>作用：可对 java.util.Date、java.uitl.calendar、java.long.Long 及 Joda 时间类型的属性进行标注，主要处理前端时间类型与后端 pojo 对象中的成员变量进行数据绑定，所约束的时间格式并<strong>不会影响后端返回前端的时间类型数据格式</strong>；</li><li><strong>注意</strong>（注意！注意！注意！讲三遍）：前端入参数据的时间格式必须与注解中定义的时间格式相同，不然会报错，如：@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm”) 则入参的格式必须为 “2020-6-4 10:43”；</li><li>常用注解属性：</li></ul><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>iso</td><td>类型为 DateTimeFormat.ISO，常用值：<br>DateTimeFormat.ISO.DATE：格式为 yyyy-MM-dd<br>DateTimeFormat.ISO.DATE_TIME：格式为 yyyy-MM-dd hh:mm:ss.SSSZ<br>DateTimeFormat.ISO.TIME：格式为 hh:mm:ss.SSSZ<br>DateTimeFormat.ISO.NONE：表示不使用 ISO 格式的时间（默认值）</td></tr><tr><td>pattern</td><td>类型为 String，使用自定义时间格式化字符串，如 "yyyy-MM-dd hh:mm:ss"</td></tr><tr><td>style</td><td>类型为 String，通过样式指定日期时间的格式，由两位字符组成，<br>第一位表示日期的样式，第二位表示时间的格式，以下是几个常用的可选值：<br>S：短日期 / 时间的样式<br>M：中日期 / 时间的样式<br>L：短日期 / 时间的样式<br>F：完整日期 / 时间的样子<br>-：忽略日期或时间的样式<br>默认值 style=“SS”</td></tr></tbody></table><h3 id="五、总结-JsonFormat-和-DateTimeFormat-区别"><a href="#五、总结-JsonFormat-和-DateTimeFormat-区别" class="headerlink" title="五、总结 @JsonFormat 和 @DateTimeFormat 区别"></a>五、总结 @JsonFormat 和 @DateTimeFormat 区别</h3><ul><li><code>@JsonFormat</code> <strong>既</strong>可以约束<strong>前端传入的时间类型参数格式</strong>，<strong>也</strong>可以约束<strong>后端响应前端的时间类型格式</strong>；</li><li><code>@DateTimeFormat</code> ：<ul><li>只能<strong>约束</strong>前端入参时间类型的格式，并不会修改原有的日期对象的格式，如果想要获得期望的日期格式，是需要自己手动转换的；</li><li>如果单独使用<code>@DateTimeFormat</code> 时，响应给前端的时间会比实际时间晚 8 个小时（时区原因）。</li><li>针对 <code>@DateTimeFormat</code> 做了补充说明，有场景示例比较详情，需要的大佬可以看一下。</li><li>传送门：<a href="https://blog.csdn.net/zhuzicc/article/details/127956849">Spring @DateTimeFormat 日期格式化时注解浅析分享</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 实际开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 实际开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发规范</title>
      <link href="/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1、关于Object-的-equals"><a href="#1、关于Object-的-equals" class="headerlink" title="1、关于Object 的 equals"></a>1、关于Object 的 equals</h1><p><code>Object.equals()</code> 方法是 Java 语言中的一个基础方法，用来比较两个对象是否相等。以下是它的源代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要注意的是，<code>Object</code> 的 <code>equals()</code> 方法是根据对象的引用来判断两个对象是否相等的，而不是根据对象的内容。如果我们要比较两个对象的内容是否相等，我们需要重写 <code>equals()</code> 方法，这样就可以根据对象的具体内容来判断它们是否相等了。不再详述。</p><p>Java 中的 <code>Objects.equals()</code> 方法实际上是由 Java 中的 <code>Objects</code> 类提供的静态方法，以下是它的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要注意的是，这个方法中使用的是逻辑或运算符 (<code>||</code>)。首先检查第一个条件是否为 <code>true</code>，只有当第一个条件为 <code>false</code> 时才会执行第二个条件。这种方式在 Java 中有时被称为 “short-circuiting”。这里也就是短路或，这种技巧可以用来提高代码的效率，避免执行不必要的操作。</p><p><code>Objects.equals()</code> 方法是 Java 中用于比较两个对象是否相等的一个实用工具方法，它可以处理对象为 <code>null</code> 的情况，避免了因对象为 <code>null</code> 而产生 <code>NullPointerException</code> 的问题。具体来说，如果两个参数都是 <code>null</code>，则返回 <code>true</code>；如果一个参数是 <code>null</code> 而另一个不是 <code>null</code>，则返回 <code>false</code>；否则，调用第一个参数的 <code>equals</code> 方法进行比较。这样就避免了空指针异常了。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Object的equals方法容易抛出空指针异常，应使用常量或确定有值的对象来调用equals。</p><p><strong>正</strong>： “test”.equals(object)</p><p><strong>反</strong>： object.equals(“test”)</p><p><strong>推荐使用JDK7引入的工具类 java.util.Objects#equals(Object a, Object b)</strong></p><h1 id="2、关于基本数据类型与包装数据类型的使用标准"><a href="#2、关于基本数据类型与包装数据类型的使用标准" class="headerlink" title="2、关于基本数据类型与包装数据类型的使用标准"></a>2、关于基本数据类型与包装数据类型的使用标准</h1><ul><li>【强制】所有POJO类属性必须使用包装数据类型</li><li>【强制】RPC方法的返回值和参数必须使用包装数据类型</li><li>【建议】所有局部变量使用基本数据类型</li></ul><p><a href="https://blog.csdn.net/qing_gee/article/details/101670051?ops_request_misc=%257B%2522request%255Fid%2522%253A%252249329805-7ED5-4DF4-9369-2022277223D4%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=49329805-7ED5-4DF4-9369-2022277223D4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-9-101670051-null-null.142%5Ev100%5Epc_search_result_base6&utm_term=%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%20%E5%8C%85%E8%A3%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%20JAVA&spm=1018.2226.3001.4187">Java基本数据类型 与 包装数据类型详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Java开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java开发规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL自增主键与UUID</title>
      <link href="/MySQL/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%8EUUID/"/>
      <url>/MySQL/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%8EUUID/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL自增主键"><a href="#MySQL自增主键" class="headerlink" title="MySQL自增主键"></a>MySQL自增主键</h1><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT</span><br></pre></td></tr></table></figure><p>插入新记录的时候可以不指定ID 的值，系统会获取当前的ID 最大值加1 作为下一条记录的ID 值。</p><p><strong>也就是说，自增主键的插入数据模式，正好符合 递增插入的场景。每插入一条新记录，都是追加操作，都不涉及挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</strong></p><p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份成号做主键，还是用自增主键做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><h2 id="UUID-与-AUTO-INCREAMENT对比"><a href="#UUID-与-AUTO-INCREAMENT对比" class="headerlink" title="UUID 与 AUTO INCREAMENT对比"></a>UUID 与 AUTO INCREAMENT对比</h2><table><thead><tr><th>UUID做主键</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1</td><td>唯一标识，不会考虑重复问题</td><td>UUID随机生成，会发生随机IO，影响插入速度，且B+树的页分裂会导致硬盘使用率低</td></tr><tr><td>2</td><td>可以在应用层生成，提高数据库吞吐率</td><td>占用空间较大</td></tr><tr><td>3</td><td>无需担心业务量泄露的风险</td><td>UUID之间比较大小比自增主键ID慢，影响查询速度</td></tr></tbody></table><p><strong>注意</strong>：InnoDB中主键索引是聚簇索引，<strong>如果主键索引是自增ID</strong>，只需按照顺序往后排即可，如果是UUID，ID是随机生成的，在数据插入时就造成大量的数据移动，发生随机ID，印象插入速度，造成硬盘的使用率较低</p><table><thead><tr><th>自增主键</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1</td><td>字段长度比UUID小</td><td>因为是自增，在某些业务场景下，容易被其他人查到业务量</td></tr><tr><td>2</td><td>数据库自动编号，插入时无需指定ID，按顺序存放，利于检索</td><td>发生数据迁移时，或者表合并时麻烦</td></tr><tr><td>3</td><td>无需担心主键重复问题</td><td>在高并发场景下，竞争自增锁会降低数据的吞吐能力</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL的更新语句是如何执行的？</title>
      <link href="/MySQL/%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
      <url>/MySQL/%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一条SQL更新语句是如何执行的？"><a href="#一条SQL更新语句是如何执行的？" class="headerlink" title="一条SQL更新语句是如何执行的？"></a>一条SQL更新语句是如何执行的？</h1><p>相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎</p><p>那么一条更新语句的执行流程？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c <span class="operator">=</span> c <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> ID <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"># 从这条更新语句出发讨论 一条<span class="keyword">SQL</span>更新语句是如何执行的</span><br></pre></td></tr></table></figure><p>你可能听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免好奇，这是怎样做到呢</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL的逻辑架构图"></p><p>你执行语句前要先链接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这张表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分词器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后执行器负责具体执行，找到这一行更新。</p><p>与查询流程不一样的是，更新流程还设计两个重要的日志模块，<strong>redo log 和 bin log</strong> </p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>背景：在MySQL里有这样一个问题，如果每一次更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后更新，整个过程IO成本，查找成本都很高。</p><p>MySQL设计者 使用WAL技术提升效率， WAL的全称是Write-Ahead-Logging，它的关键点就是先写日志，再写磁盘</p><p>具体来说就是，当有一条记录需要更新的时候，InnoDB引擎会先把记录写到redo log里面，并更新内存，这个时候更新就完成了，然后InnoDB引擎会在合适的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做的，</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块总共就可以记录4GB的操作，从头开始写到末尾，就又回到开头循环写</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/16a7950217b3f0f4ed02db5db59562a7.png" alt="img"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p><ol><li>执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></p><h2 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两阶段提交原理描述：</span><br><span class="line"><span class="code">    1、InnoDB redo log 写盘，InnoDB事物进入prepare状态。</span></span><br><span class="line"><span class="code">    2、如果prepare成功，binlog 写盘，那么再继续将事物日志持久化到binlog，如果持久化成功，那么InnoDB事物则会进入commit状态（在redo log里面写一个commit记录）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">备注： 每个事物binlog 的末尾，会记录一个XID event， 标志着事物是否是否提交成功，也就是说，回滚过程中，binlog最后一个XID event之后的内容都应该会被清除</span><br></pre></td></tr></table></figure><p>为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于redo log 和 bin log  是独立的逻辑，如果不用两阶段提交，要么就是先写完redo log 再写 bin log 或者采用反过来的顺讯。我们看看这两种方式有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID &#x3D; 2的行，字段c的值是0，再假设执行update语句的过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><p>1、<strong>先写redo log 后写 binlog</strong>。 假设在redo log写完，binlog 还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1.</p><p>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个binlog丢失，这个临时哭就会少了这一次更新，恢复出来的这一行c的值就是0，与原库不同</p><p>2、<strong>先写binlog 后写redo log</strong>。 如果在binlog写完之后crash ，由于 redo log 还没写，崩溃恢复后这个食物无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，之后用binlog来恢复的时候就多了一个事物出来，恢复出来的这一行c的值就是1，与原库不同。</p><p>— 如果不使用“两阶段提交” ，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</p><p><strong>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL使用B+树不使用跳表?(Reids中Zset使用跳表不使用B+树)</title>
      <link href="/MySQL/MySQL%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8-Reids%E4%B8%ADZset%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E4%B8%8D%E4%BD%BF%E7%94%A8B-%E6%A0%91/"/>
      <url>/MySQL/MySQL%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8-Reids%E4%B8%ADZset%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E4%B8%8D%E4%BD%BF%E7%94%A8B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>在我们的印象中，MySQL 数据表里无非就是存储一行行的数据。跟个 [直接遍历这一行行数据，性能就是 O(n)，比较慢。为了加速查询，使用了 <strong>B + 树</strong>来做索引，将查询性能优化到了 **O(lg(n))**。</p><p>但问题就来了，查询数据性能在 lg(n) 级别的数据结构有很多，<font style="color:rgb(37, 37, 37);">比如</font>redis<font style="color:rgb(37, 37, 37);">的zset里用到的</font><strong><font style="color:rgb(37, 37, 37);">跳表</font></strong><font style="color:rgb(37, 37, 37);">，也是</font><strong><font style="color:rgb(37, 37, 37);">lg(n)</font></strong><font style="color:rgb(37, 37, 37);">，并且实现还贼简单。</font></p><p><strong><font style="color:rgb(37, 37, 37);">那为什么mysql的索引，不使用跳表呢？</font></strong></p><h2 id="一、B-树"><a href="#一、B-树" class="headerlink" title="一、B+ 树"></a>一、B+ 树</h2><p> B + 树的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/f452ce5439f04e98bb061be352c5489c"></p><p>B + 树查询过程</p><p>如上图，一般 B + 树是由多个页组成的<strong>多层级</strong>结构，每个页 16Kb，对于主键索引来说，最末级的<strong>叶子结点</strong>放行数据，<strong>非叶子结点</strong>放的则是索引信息（主键 id 和页号），用于加速查询。</p><p>比方说我们想要查找行数据 5。会先从顶层页的 record 们入手。<strong>record 里包含了主键 id 和页号（页地址）</strong>。关注黄色的箭头，向左最小 id 是 1，向右最小 id 是 7。那 id&#x3D;5 的数据如果存在，那必定在左边箭头。于是顺着的 record 的页地址就到了 6 号数据页里，再判断 id&#x3D;5&gt;4，所以肯定在右边的数据页里，于是加载 105 号数据页。</p><p>在 105 号数据页里，虽然有多行数据，但也<strong>不是挨个遍历的</strong>，数据页内还有个<strong>页目录</strong>的信息，它可以通过<strong>二分查找</strong>的方式加速查询行数据，于是找到 id&#x3D;5 的数据行，完成查询。</p><p>从上面可以看出，B + 树利用了<strong>空间换时间</strong>的方式（构造了一批非叶子结点用于存放索引信息），**将查询时间复杂度从 O(n) 优化为 O(lg(n))**。</p><h2 id="二、跳表"><a href="#二、跳表" class="headerlink" title="二、跳表"></a>二、跳表</h2><p>（具体查询方式见 Redis–跳表原理）</p><p>看完 B + 树，我们再来看下跳表是怎么来的。</p><p>同样的，还是为了存储一行行的数据。</p><p>我们可以将它们用<strong>链表</strong>串起来。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/d763b4412f4b4cd682908507be08589a"></p><p>单链表</p><p>想要查询链表中的其中一个结点，时间复杂度是 O(n)，这谁顶得住，于是将<strong>部分</strong>链表结点提出来，再构建出一个新的链表。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/9fb38c939d684ae1b596516ddd7d169a"></p><p>两层跳表</p><p>这样当我想要查询一个数据的时候，我先查上层的链表，就很容易知道数据落在<strong>哪个范围</strong>，然后<strong>跳到下一个层级里进行查询。</strong>这样就把搜索范围一下子缩小了一大半。</p><p>比如查询 id&#x3D;10 的数据，我们先在上层遍历，依次判断 1,6,12，很快就可以判断出 10 在 6 到 12 之间，然后往下一跳，就可以在遍历 6,7,8,9,10 之后，确定 id&#x3D;10 的位置。直接将查询范围从原来的 1 到 10，变成现在的 1,6,7,8,9,10，算是砍半了。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/a86edf7371be419c833d550fc9f8935e"></p><p>两层跳表查找 id 为 10 的数据</p><p>既然两层链表就直接将查询范围砍半了，那我<strong>多加几层</strong>，岂不妙哉？</p><p>于是跳表就这样变成了多层。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/0d005de1d63f45faad1ba79ba8a9afcd"></p><p>三层跳表</p><p>如果还是查询 id&#x3D;10 的数据，就只需要查询 1,6,9,10 就能找到，比两层的时候更快一些。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/8ec273f9a79e43b68b101ff37289ec5b"></p><p>三层跳表查询 id 为 10 的数据</p><h2 id="三、插入对比"><a href="#三、插入对比" class="headerlink" title="三、插入对比"></a>三、插入对比</h2><p>可以看出，跳表也是通过<strong>牺牲空间换取时间</strong>的方式提升查询性能。**时间复杂度都是 lg(n)**。</p><p>从上面可以看到，B + 树和跳表的<strong>最下面一层，都包含了所有的数据</strong>，且都是<strong>顺序的，适合用于范围查询</strong>。往上的层级都是构建出来用于提升搜索性能的。这两者实在是太像了。但他们两者在<strong>新增和删除数据</strong>时，还是有些区别的。下面我们以新增数据为例聊一下。</p><p>B + 树本质上是一种多叉平衡二叉树。</p><p>关键在于 “ <strong>平衡</strong> “ 这两个字，对于多叉树结构来说，它的含义是子树们的高度层级尽量一致（一般最多差一个层级），这样在搜索的时候，不管是到哪个子树分支，搜索次数都差不了太多。</p><p>当数据库表不断插入新的数据时，为了维持 B + 树的平衡，B + 树会不断分裂调整数据页。</p><p>我们知道 B + 树分为<strong>叶子结点和非叶子结点</strong>。</p><p>当插入一条数据时，叶子结点和它上层的索引结点（非叶子结点）最大容量都是 16k，它们都有可能会满。</p><p>为了简化问题，我们<strong>假设</strong>一个数据页只能放三条行数据或索引。</p><p>加入一条数据，根据数据页会不会满，分为三种情况。</p><ul><li><strong>叶子结点和索引结点都没满</strong>。这种情况最简单，直接插入到叶子结点中就好了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/e07aa8a79e9843d39f1683816b16aaee"></p><p>叶子和非叶子都未满</p><ul><li><strong>叶子结点满了，但索引结点没满</strong>。此时需要拆分叶子结点，同时索引结点要增加新的索引信息。</li></ul><p><img src="https://p9.toutiaoimg.com/origin/tos-cn-i-qvj2lq49k0/d5a6e764c24c448aa2b8c5ecd9a45aed?from=pc"></p><p>叶子满了但非叶子未满. drawio</p><ul><li><strong>叶子结点满了，且索引结点也满了</strong>。叶子和索引结点都要拆分，同时往上还要再<strong>加一层索引。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/ab113f85f7a44f9f9364a29817fb9371"></p><p>叶子和非叶子都满了</p><p>从上面可以看到，只有在叶子和索引结点<strong>都满了</strong>的情况下，B + 树才会考虑加入一层新的结点。</p><p>而从之前的文章知道，要把三层 B + 树塞满，那大概需要 2kw 左右的数据。</p><p>跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据。</p><p>此时，<strong>是否需要在上面的几层中加入数据做索引呢？</strong></p><p>这个就纯靠<strong>随机函数</strong>了。</p><p>理论上为了达到<strong>二分的效果</strong>，每一层的结点数需要是下一层结点数的二分之一。</p><p>也就是说现在有一个新的数据插入了，它有 50% 的概率需要在第二层加入索引，有 25% 的概率需要在第三层加个索引，以此类推，直到最顶层。</p><p>举个例子，如果跳表中插入数据 id&#x3D;6，且随机函数返回第三层（有 25% 的概率），那就需要在跳表的最底层到第三层都插入数据。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/imgs/8c27573cf77343ad87633788736eb02f"></p><p>跳表插入数据</p><p>如果这个随机函数设计成上面这样，当<strong>数据量样本足够大</strong>的时候，数据的分布就符合我们理想中的 “二分”。</p><p>跟上面 B + 树不一样，跳表是否新增层数，纯粹靠随机函数，根本不关心前后上下结点。</p><p>好了，基础科普也结束了，我们可以进入正题了。</p><h2 id="四、总结（重点！！！）"><a href="#四、总结（重点！！！）" class="headerlink" title="四、总结（重点！！！）"></a>四、总结（重点！！！）</h2><p><strong>B + 树</strong>是多叉树结构，每个结点都是一个 16k 的数据页，能存放较多索引信息，所以<strong>扇出很高</strong>。<strong>三层</strong>左右就可以存储 2kw 左右的数据（知道结论就行，想知道原因可以看之前的文章）。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询<strong>三次磁盘 IO</strong>。</p><p><strong>跳表</strong>是链表结构，一条数据一个结点，如果最底层要存放 2kw 数据，且每次查询都要能达到<strong>二分查找</strong>的效果，2kw 大概在 2 的 24 次方左右，所以，跳表大概高度在 <strong>24 层</strong>左右。最坏情况下，这 24 层数据会分散在不同的数据页里，也即是查一次数据会经历 <strong>24 次磁盘 IO</strong>。</p><p>因此存放同样量级的数据，B + 树的高度比跳表的要少，如果放在 mysql 数据库上来说，就是<strong>磁盘 IO 次数更少，因此 B + 树查询更快</strong>。</p><p>而针对<strong>写操作</strong>，B + 树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此<strong>跳表的写入性能会比 B + 树要好。</strong></p><p>其实，mysql 的<strong>存储引擎是可以换的</strong>，以前是 myisam，后来才有的 innodb，它们底层索引用的都是 <strong>B + 树</strong>。也就是说，你完全可以造一个索引为跳表的存储引擎装到 mysql 里。事实上，facebook 造了个 rocksDB 的存储引擎，里面就用了<strong>跳表</strong>。直接说结论，它的<strong>写入性能</strong>确实是比 innodb 要好，但<strong>读性能</strong>确实比 innodb 要差不少。</p><h2 id="五、为什么Redis-里面用跳表-而-MySQL里面用B-树？（关键）"><a href="#五、为什么Redis-里面用跳表-而-MySQL里面用B-树？（关键）" class="headerlink" title="五、为什么Redis 里面用跳表 而 MySQL里面用B+树？（关键）"></a>五、为什么Redis 里面用跳表 而 MySQL里面用B+树？（关键）</h2><p>redis 支持多种数据结构，里面有个<strong>有序集合</strong>，也叫 <strong>ZSET</strong>。内部实现就是<strong>跳表</strong>。那为什么要<strong>用跳表而不用 B + 树等结构呢？</strong></p><p>大家知道，redis 是纯纯的内存数据库。</p><p>进行读写数据都是操作内存，跟磁盘没啥关系，因此也<strong>不存在磁盘 IO</strong> 了，所以层高就不再是跳表的劣势了。</p><p>并且前面也提到 B + 树是有一系列合并拆分操作的，换成红黑树或者其他 AVL 树的话也是各种旋转，目的也是<strong>为了保持树的平衡</strong>。</p><p>而跳表插入数据时，只需要随机一下，就知道自己要不要往上加索引，根本不用考虑前后结点的感受，也就<strong>少了旋转平衡的开销</strong>。</p><p>因此，redis 选了跳表，而不是 B + 树。</p><ul><li>B + 树是多叉平衡搜索树，扇出高，只需要 3 层左右就能存放 2kw 左右的数据，同样情况下跳表则需要 24 层左右，假设层高对应<strong>磁盘 IO</strong>，那么 B + 树的读性能会比跳表要好，因此 mysql 选了 B + 树做索引。</li><li>redis 的读写全在内存里进行操作，不涉及磁盘 IO，同时跳表实现简单，相比 B + 树、AVL 树、少了旋转树结构的开销，因此 redis 使用跳表来实现 ZSET，而不是树结构。</li><li>存储引擎 RocksDB 内部使用了跳表，对比使用 B + 树的 innodb，虽然写性能更好，但读性能属实差了些。在读多写少的场景下，B + 树依旧 YYDS。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java日志框架--转载</title>
      <link href="/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
      <url>/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>随着互联网和大数据的迅猛发展，分布式日志系统和日志分析系统已广泛应用，几乎所有应用程序都使用各种日志框架记录程序运行信息。因此，作为工程师，了解主流的日志记录框架非常重要。虽然应用程序的运行结果不受日志的有无影响，但没有日志的应用程序是不完整的，甚至可以说是有缺陷的。优秀的日志系统可以<strong>记录操作轨迹</strong>、<strong>监控系统运行状态</strong>和<strong>解决系统故障</strong>。</p><hr><p>目前常用的日志框架有 Log4j，Log4j 2，Commons Logging，Slf4j，Logback，JUL。这些日志框架可以分为两种类型：门面日志和日志系统。</p><h2 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a>日志门面</h2><p><strong>日志门面（Logging Facade</strong> 是一种设计模式，用于在应用程序中实现日志记录的抽象层。它提供了一组统一的接口和方法，即相应的 API，而不提供具体的接口实现。日志门面在使用时，可以动态或者静态地指定具体的日志框架实现，解除了接口和实现的耦合，使用户可以灵活地选择日志的具体实现框架。</p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p><strong>日志系统（Logging System</strong> 是指用于记录和管理应用程序运行时产生的日志信息的软件工具或框架。与日志门面相对，它提供了具体的日志接口实现，应用程序通过它执行日志打印的功能，如日志级别管理、日志格式化、日志输出目标设置等。常见的日志系统包括 Log4j、Logback、Java Util Logging 等。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/81435ba595d54cf0b988d3ce21b509c7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp"></p><p>通过使用日志门面，我们可以在应用程序中使用统一的 API 进行日志记录，而具体的日志实现可以根据需要选择和配置。这样，我们可以根据项目需求和团队喜好来灵活选择、切换和配置日志系统，而不会对应用程序代码造成太大影响。</p><h2 id="避免环形依赖"><a href="#避免环形依赖" class="headerlink" title="避免环形依赖"></a>避免环形依赖</h2><p>Slf4j 的作者 Ceki Gülcü 当年因为觉得 Commons-Logging 的 API 设计的不好，性能也不够高，因而设计了 Slf4j。而他为了 Slf4j 能够兼容各种类型的日志系统实现，还设计了相当多的 adapter 和 bridge 来连接，如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/8e666d107e3649569408a51e08509240~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" style="zoom:50%;" /><p>鉴于此，在引入日志框架依赖的时候要尽力避免，比如以下组合就不能同时出现：</p><p>•jcl-over-slf4j 和 slf4j-jcl</p><p>•log4j-over-slf4j 和 slf4j-log4j12</p><p>•jul-to-slf4j 和 slf4j-jdk14</p><h2 id="日志框架的使用选择"><a href="#日志框架的使用选择" class="headerlink" title="日志框架的使用选择"></a>日志框架的使用选择</h2><p>常用的组合使用方式是 Slf4j &amp; Logback 组合使用，Commons Logging &amp; Log4j 组合使用。</p><p><strong>推荐</strong>：</p><p>Slf4j &amp; Logback</p><p><strong>原因</strong>：</p><ol><li><p>Slf4j 实现机制决定 Slf4j 限制较少，使用范围更广。相较于 Commons-Logging，Slf4j 在编译期间便静态绑定本地的 Log 库，其通用性要好得多；</p></li><li><p>Logback 拥有更好的性能。Logback 声称：某些关键操作，比如判定是否记录一条日志语句的操作，其性能得到了显著的提高，这个操作在 Logback 中只需 3 ns，而在 Log4j 则需要 30 ns；</p></li><li><p>Slf4j 支持参数化，使用占位符号，代码更为简洁，如下例子：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在使用 Commons-Logging 时，通常的做法是 </span></span><br><span class="line"><span class="keyword">if</span>(log.isDebugEnabled())&#123; </span><br><span class="line">    log.debug(<span class="string">&quot;User name： &quot;</span> + user.getName() + <span class="string">&quot; buy goods id ：&quot;</span> + good.getId()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Slf4j 阵营，你只需这么做： </span></span><br><span class="line">log.debug(<span class="string">&quot;User name：&#123;&#125; ,buy goods id ：&#123;&#125;&quot;</span>, user.getName(),good.getId());</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>Logback 的所有文档是免费提供的，Log4j 只提供部分免费文档而需要用户去购买付费文档；</p></li><li><p>MDC (Mapped Diagnostic Contexts) 用 Filter，将当前用户名等业务信息放入 MDC 中，在日志 format 定义中即可使用该变量。具体而言，在诊断问题时，通常需要打出日志。如果使用 Log4j，则只能降低日志级别，但是这样会打出大量的日志，影响应用性能；如果使用 Logback，保持原定日志级别而过滤某种特殊情况，如 Alice 这个用户登录，日志将打在 DEBUG 级别而其它用户可以继续打在 WARN 级别。实现这个功能只需加 4 行 XML 配置；</p></li><li><p>自动压缩日志。RollingFileAppender 在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩过程是异步的，因此在压缩过程中应用几乎不会受影响。</p></li></ol><hr><h2 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h2><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--日志框架接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志框架接口实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志框架核心组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--自动化注解工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>logback.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--默认日志配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制台日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Info日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE-INFO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;-info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>NEUTRAL<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span> <span class="comment">&lt;!-- 日志文件的路径和名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>200MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span> <span class="comment">&lt;!-- 单个日志文件的最大大小 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span> <span class="comment">&lt;!-- 保留的历史日志文件数量 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>2GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span> <span class="comment">&lt;!-- 所有日志文件的总大小上限 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cleanHistoryOnStart</span>&gt;</span>true<span class="tag">&lt;/<span class="name">cleanHistoryOnStart</span>&gt;</span> <span class="comment">&lt;!-- 在启动时清除历史日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Warn日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE-WARN&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;-warn.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span> <span class="comment">&lt;!-- 日志文件的路径和名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>200MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span> <span class="comment">&lt;!-- 单个日志文件的最大大小 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span> <span class="comment">&lt;!-- 保留的历史日志文件数量 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>2GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span> <span class="comment">&lt;!-- 所有日志文件的总大小上限 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cleanHistoryOnStart</span>&gt;</span>true<span class="tag">&lt;/<span class="name">cleanHistoryOnStart</span>&gt;</span> <span class="comment">&lt;!-- 在启动时清除历史日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Error日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE-ERROR&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;-error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;LOG_FILE&#125;-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>200MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>2GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cleanHistoryOnStart</span>&gt;</span>true<span class="tag">&lt;/<span class="name">cleanHistoryOnStart</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 异步输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;info-asyn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE-INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>512<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span> <span class="comment">&lt;!-- 异步队列的大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;warn-asyn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE-WARN&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>512<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span> <span class="comment">&lt;!-- 异步队列的大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;error-asyn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE-ERROR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>512<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 应用日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.improve.fuqige.bronze&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE-INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE-WARN&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE-ERROR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 总日志出口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;logging.level.root&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;info-asyn&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;warn-asyn&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;error-asyn&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>applicantion.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.file</span>=<span class="string">fuqige-bronze</span></span><br><span class="line"><span class="attr">logging.path</span>=<span class="string">XXXXXX/Logs/XXXXXX</span></span><br><span class="line"><span class="attr">logging.level.root</span>=<span class="string">info</span></span><br><span class="line"><span class="attr">logging.level.com.improve.fuqige.bronze</span>=<span class="string">info</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=<span class="string">%cyan(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;) %yellow([%thread]) %highlight(%-5level) %boldGreen(%logger&#123;80&#125;[LineNumber:%L]): %highlight(%msg%n)</span></span><br><span class="line"><span class="attr">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%X&#123;requestId&#125;] %-5level --- [%thread] %logger&#123;80&#125;[LineNumber:%L]: %msg%n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;进来了!&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;进来了!&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;进来了!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, world! requestId=&quot;</span> + MDC.get(<span class="string">&quot;requestId&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>参考资料</p><p>Java 日志框架： <a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/365154773" title="https://zhuanlan.zhihu.com/p/365154773">zhuanlan.zhihu.com&#x2F;p&#x2F;365154773</a></p><p>SLF4J 框架常见的用法和最佳实践： <a href="https://juejin.cn/post/7215569601161166906" title="https://juejin.cn/post/7215569601161166906">juejin.cn&#x2F;post&#x2F;721556…</a></p><p>作者：京东零售 张洪</p><p>来源：京东云开发者社区 转载请注明来源</p>]]></content>
      
      
      <categories>
          
          <category> 日志框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok中@Slf4j使用</title>
      <link href="/uncategorized/Lombok%E4%B8%AD-Slf4j%E4%BD%BF%E7%94%A8/"/>
      <url>/uncategorized/Lombok%E4%B8%AD-Slf4j%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>纪录一次使用 LomBok @Slf4j 爆红的历史</p><h2 id="使用Slf4j-和-logback纪录日志"><a href="#使用Slf4j-和-logback纪录日志" class="headerlink" title="使用Slf4j 和 logback纪录日志"></a>使用Slf4j 和 logback纪录日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shaochenguang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/9/26 16:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> testLombokLog</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testLombokLog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(testLombokLog.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;wcnm终于好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用lombok纪录日志的流程"><a href="#使用lombok纪录日志的流程" class="headerlink" title="使用lombok纪录日志的流程"></a>使用lombok纪录日志的流程</h2><p>使用lombok插件和@Slf4j注解能够减少<br>private static final Logger log &#x3D; LoggerFactory.getLogger(类.class);</p><p>1、使用IDEA 首先安装Lombok 插件</p><p>2、 再pom文件中加入 lombok的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!--版本号自己选一个就行--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、再需要打印日志的类上面加入@Slf4j注解</p><p>然后就可以在类中使用 log.info() 等进行打印日志了</p><p><strong>但是，经过上述步骤后 log.info()爆红</strong></p><p><strong>解决方式</strong>:重新加入下述注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="原因：TODO"><a href="#原因：TODO" class="headerlink" title="原因：TODO"></a>原因：TODO</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KafKa基础原理</title>
      <link href="/KafKa/KafKa%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
      <url>/KafKa/KafKa%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概念理解"><a href="#一、概念理解" class="headerlink" title="一、概念理解"></a>一、概念理解</h3><p><strong>Kafka</strong> 是最初由 Linkedin 公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于 zookeeper 协调的<strong>分布式消息系统</strong>，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于 hadoop 的批处理系统、低延迟的实时系统、storm&#x2F;Spark 流式处理引擎，web&#x2F;nginx 日志、访问日志，消息服务等等，用 scala 语言编写，Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源 项目。</p><h4 id="（1）产生背景"><a href="#（1）产生背景" class="headerlink" title="（1）产生背景"></a>（1）产生背景</h4><p>当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：</p><ol><li>如何收集这些巨大的信息</li><li>如何分析它</li><li>如何及时做到如上两点</li></ol><p>以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁 - 消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。</p><p><strong>Kafka 诞生</strong> Kafka 由 linked-in 开源 kafka - 即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。 kafka - 高产出的分布式消息系统 (A high-throughput distributed messaging system)</p><h4 id="（2）Kafka-的特性"><a href="#（2）Kafka-的特性" class="headerlink" title="（2）Kafka 的特性"></a>（2）Kafka 的特性</h4><table><thead><tr><th>特性</th><th>分布式</th><th>高性能</th><th>持久性和扩展行</th></tr></thead><tbody><tr><td></td><td>多分区</td><td>高吞吐量</td><td>数据可持久化</td></tr><tr><td></td><td>多副本</td><td>低延迟</td><td>容错性</td></tr><tr><td></td><td>多订阅者</td><td>高并发</td><td>支持水平在线扩展</td></tr><tr><td></td><td>基于ZooKeeper调度</td><td>时间复杂度O（1）</td><td>消息自动平衡</td></tr></tbody></table><ul><li><strong>高吞吐量、低延迟</strong>：kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li><li><strong>可扩展性</strong>：kafka 集群支持热扩展</li><li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li><strong>容错性</strong>：允许集群中节点失败（若副本数量为 n, 则允许 n-1 个节点失败）</li><li><strong>高并发</strong>：支持数千个客户端同时读写</li></ul><h4 id="（3）Kafka-场景应用"><a href="#（3）Kafka-场景应用" class="headerlink" title="（3）Kafka 场景应用"></a>（3）Kafka 场景应用</h4><ul><li><strong>日志收集</strong>：一个公司可以用 Kafka 可以收集各种服务的 log，通过 kafka 以统一接口服务的方式开放给各种 consumer，例如 hadoop、Hbase、Solr 等。</li><li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。</li><li><strong>用户活动跟踪</strong>：Kafka 经常被用来记录 web 用户或者 app 用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到 kafka 的 topic 中，然后订阅者通过订阅这些 topic 来做实时的监控分析，或者装载到 hadoop、数据仓库中做离线分析和挖掘。</li><li><strong>运营指标</strong>：Kafka 也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li><li><strong>流式处理</strong>：比如 spark streaming 和 storm</li><li><strong>事件源</strong></li></ul><h4 id="（4）Kafka-一些重要设计思想"><a href="#（4）Kafka-一些重要设计思想" class="headerlink" title="（4）Kafka 一些重要设计思想"></a>（4）Kafka 一些重要设计思想</h4><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/image-20240924190102682.png" alt="KafKa架构"></p><ul><li><strong>Consumergroup</strong>：KafKa是按消费组来消费消息的，一个消费组下面的所有机器可以组成一个Consumer Group，每条消息只能被该Consumer Group一个Consumer消费，不容的Consumer Group可以消费同一条消息</li><li><strong>消息状态</strong>：在 Kafka 中，消息的状态被保存在 consumer 中，broker 不会关心哪个消息被消费了被谁消费了，只记录一个 offset 值（指向 partition 中下一个要被消费的消息位置），这就意味着如果 consumer 处理不好的话，broker 上的一个消息可能会被消费多次。</li><li><strong>消息持久化</strong>：Kafka 中会把消息持久化到本地文件系统中，并且保持极高的效率。</li><li><strong>消息有效期</strong>：Kafka 会长久保留其中的消息，以便 consumer 可以多次消费，当然其中很多细节是可配置的。</li><li><strong>批量发送</strong>：Kafka 支持以消息集合为单位进行批量发送，以提高 push 效率。</li><li><strong>push-and-pull</strong> :Kafka 中的 Producer 和 consumer 采用的是 push-and-pull 模式，即 Producer 只管向 broker push 消息，consumer 只管从 broker pull 消息，两者对消息的生产和消费是异步的。</li><li><strong>Kafka 集群中 broker 之间的关系</strong>：不是主从关系，各个 broker 在集群中地位一样，我们可以随意的增加或删除任何一个 broker 节点。</li><li><strong>负载均衡方面</strong>： Kafka 提供了一个 metadata API 来管理 broker 之间的负载（对 Kafka0.8.x 而言，对于 0.7.x 主要靠 zookeeper 来实现负载均衡）。</li><li><strong>同步异步</strong>：Producer 采用异步 push 方式，极大提高 Kafka 系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li><li><strong>分区机制 partition</strong>：Kafka 的 broker 端支持消息分区，Producer 可以决定把消息发到哪个分区，在一个分区中消息的顺序就是 Producer 发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</li><li><strong>离线数据装载</strong>：Kafka 由于对可拓展的数据持久化的支持，它也非常适合向 Hadoop 或者数据仓库中进行数据装载。</li><li><strong>插件支持</strong>：现在不少活跃的社区已经开发出不少插件来拓展 Kafka 的功能，如用来配合 Storm、Hadoop、flume 相关的插件。</li></ul><h3 id="二、消息队列通信的模式"><a href="#二、消息队列通信的模式" class="headerlink" title="二、消息队列通信的模式"></a>二、消息队列通信的模式</h3><h4 id="（1）点对点模式"><a href="#（1）点对点模式" class="headerlink" title="（1）点对点模式"></a>（1）点对点模式</h4><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/c076a56492c6ab4c1768ac8be584ad81.png"></p><p>如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p><h4 id="（2）发布订阅模式"><a href="#（2）发布订阅模式" class="headerlink" title="（2）发布订阅模式"></a>（2）发布订阅模式</h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-8223537/45ac0cf0a61afe236bd86a8348ad9848.png"></p><p>如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是 consumer1、consumer2、consumer3 由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是 8M&#x2F;s、5M&#x2F;s、2M&#x2F;s，如果队列推送的速度为 5M&#x2F;s，则 consumer3 无法承受！如果队列推送的速度为 2M&#x2F;s，则 consumer1、consumer2 会出现资源的极大浪费！</p><h3 id="三、Kafka-的架构原理"><a href="#三、Kafka-的架构原理" class="headerlink" title="三、Kafka 的架构原理"></a>三、Kafka 的架构原理</h3><h4 id="（1）基础架构与名词解释"><a href="#（1）基础架构与名词解释" class="headerlink" title="（1）基础架构与名词解释"></a>（1）基础架构与名词解释</h4><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/935e34114a00ca407c376a24b340341b.png"></p><p>在这里插入图片描述</p><ul><li>Producer：Producer 即生产者，消息的产生者，是消息的入口。</li><li>Broker： 一个Kafka集群中的一台服务器就是一个Broker，Broker可以水平无限扩展，同一个Topic中的消息可以分布在多个Broker中。</li><li>Topic：消息的主题，可以理解为消息的分类，kafka 的数据就保存在 topic。在每个 broker 上都可以创建多个 topic。</li><li>Partition：Topic 的分区，每个 topic 可以有多个分区，分区的作用是做负载，提高 kafka 的吞吐量。同一个 topic 在不同的分区的数据是不重复的，partition 的表现形式就是一个一个的文件夹！</li><li>Replication: 每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为 Leader。在 kafka 中默认副本的最大数量是 10 个，且副本的数量不能大于 Broker 的数量，follower 和 leader 绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li><li>Message：每一条发送的消息主体。</li><li>Consumer：消费者，即消息的消费方，是消息的出口。</li><li>Consumer Group：我们可以将多个消费组组成一个消费者组，在 kafka 的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个 topic 的不同分区的数据，这也是为了提高 kafka 的吞吐量！</li><li>Zookeeper：kafka 集群依赖 zookeeper 来保存集群的的元信息，来保证系统的可用性。</li></ul><h4 id="（2）工作流程分析"><a href="#（2）工作流程分析" class="headerlink" title="（2）工作流程分析"></a>（2）工作流程分析</h4><h5 id="（1）发送数据"><a href="#（1）发送数据" class="headerlink" title="（1）发送数据"></a>（1）发送数据</h5><p>我们看上面的架构图中，producer 就是生产者，是数据的入口。注意看图中的红色箭头，<strong>Producer 在写入数据的时候永远的找 leader</strong>，不会直接将数据写入 <strong>follower</strong>！那 leader 怎么找呢？写入的流程又是什么样的呢？我们看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/882ff36ad77ac28c3ce824f299bcef26.png"></p><p>发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入 leader 后，follower 是主动的去 leader 进行同步的！producer 采用 push 模式将数据发布到 broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/cb151f6c9a4bab2e5f42376b4514e335.png"></p><p>在这里插入图片描述上面说到数据会写入到不同的分区，那 kafka 为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：</p><ol><li><strong>方便扩展</strong>：因为一个 topic 可以有多个 partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</li><li><strong>提高并发</strong>：以 partition 为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li></ol><p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在 kafka 中，如果某个 topic 有多个 partition，producer 又怎么知道该将数据发往哪个 partition 呢？</p><p>kafka 中有几个原则：</p><ol><li>partition 在写入的时候可以指定需要写入的 partition，如果有指定，则写入对应的 partition。</li><li>如果没有指定 partition，但是设置了数据的 key，则会根据 key 的值 hash 出一个 partition。</li><li>如果既没指定 partition，又没有设置 key，则会轮询选出一个 partition。</li></ol><p>保证消息不丢失是一个消息队列中间件的基本保证，那 producer 在向 kafka 写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过 ACK 应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认 kafka 接收到数据，这个参数可设置的值为 <strong>0、1、all</strong>。</p><ul><li>0 代表 producer 往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li><li>1 代表 producer 往集群发送数据只要 leader 应答就可以发送下一条，只确保 leader 发送成功。</li><li>all 代表 producer 往集群发送数据需要所有的 follower 都完成从 leader 的同步才会发送下一条，确保 leader 发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li></ul><p>最后要注意的是，如果往不存在的 topic 写数据，能不能写入成功呢？kafka 会自动创建 topic，分区和副本的数量根据默认配置都是 1。</p><h5 id="（2）保存数据"><a href="#（2）保存数据" class="headerlink" title="（2）保存数据"></a>（2）保存数据</h5><p>Producer 将数据写入 kafka 后，集群就需要对数据进行保存了！kafka 将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka 初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p><h6 id="（1）Partition-结构"><a href="#（1）Partition-结构" class="headerlink" title="（1）Partition 结构"></a>（1）Partition 结构</h6><p>前面说过了每个 topic 都可以分为一个或多个 partition，如果你觉得 topic 比较抽象，那 partition 就是比较具体的东西了！Partition 在服务器上的表现形式就是一个一个的文件夹，每个 partition 的文件夹下面会有多组 segment 文件，每组 segment 文件又包含. index 文件、.log 文件、.timeindex 文件（早期版本中没有）三个文件， log 文件就实际是存储 message 的地方，而 index 和 timeindex 文件为索引文件，用于检索消息。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/706d31956c65fa740a4bf906fc81cd5c.png"></p><p>如上图，这个 partition 有三组 segment 文件，每个 log 文件的大小是一样的，但是存储的 message 数量是不一定相等的（每条的 message 大小不一致）。文件的命名是以该 segment 最小 offset 来命名的，如 000.index 存储 offset 为 0~368795 的消息，kafka 就是利用分段 + 索引的方式来解决查找效率的问题。</p><h6 id="（2）Message-结构"><a href="#（2）Message-结构" class="headerlink" title="（2）Message 结构"></a>（2）Message 结构</h6><p>上面说到 log 文件就实际是存储 message 的地方，我们在 producer 往 kafka 写入的也是一条一条的 message，那存储在 log 中的 message 是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型…… 等等！我们重点需要知道的是下面三个：</p><ul><li><strong>offset</strong>：offset 是一个占 8byte 的有序 id 号，它可以唯一确定每条消息在 parition 内的位置！</li><li><strong>消息大小</strong>：消息大小占用 4byte，用于描述消息的大小。</li><li><strong>消息体</strong>：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</li></ul><h6 id="（3）存储策略"><a href="#（3）存储策略" class="headerlink" title="（3）存储策略"></a>（3）存储策略</h6><p>无论消息是否被消费，kafka 都会保存所有的消息。那对于旧数据有什么删除策略呢？</p><ul><li>基于时间，默认配置是 168 小时（7 天）。</li><li>基于大小，默认配置是 1073741824。</li></ul><p>需要注意的是，kafka 读取特定消息的时间复杂度是 O(1)，所以这里删除过期的文件并不会提高 kafka 的性能！</p><h5 id="（3）消费数据"><a href="#（3）消费数据" class="headerlink" title="（3）消费数据"></a>（3）消费数据</h5><p>消息存储在 log 文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka 采用的是发布订阅模式，消费者主动的去 kafka 集群拉取消息，与 producer 相同的是，消费者在拉取消息的时候也是找 <strong>leader</strong> 去拉取。</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/481a974a70b23c51494c8209b15b78f5.png"></p><p>图示是消费者组内的消费者小于 partition 数量的情况，所以会出现某个消费者消费多个 partition 数据的情况，消费的速度也就不及只处理一个 partition 的消费者的处理速度！如果是消费者组的消费者多于 partition 的数量，那会不会出现多个消费者消费同一个 partition 的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何 partition 的数据。所以在实际的应用中，</p><p><u><strong>建议消费者组的 consumer 的数量与 partition 的数量一致</strong>！</u></p><p>在保存数据的小节里面，我们聊到了 partition 划分为多组 segment，每个 segment 又包含. log、.index、.timeindex 文件，存放的每条 message 包含 offset、消息大小、消息体…… 我们多次提到 segment 和 offset，查找消息的时候是怎么利用 segment+offset 配合查找的呢？假如现在需要查找一个 offset 为 368801 的 message 是什么样的过程呢？我们先看看下面的图：</p><p><img src="https://cdn.jsdelivr.net/gh/cgshao02/BLOG_images/img/9538b991029028098618a677fc88e0f0.png"></p><ol><li>先找到 offset 的 368801message 所在的 segment 文件（利用二分法查找），这里找到的就是在第二个 segment 文件。</li><li>打开找到的 segment 中的. index 文件（也就是 368796.index 文件，该文件起始偏移量为 368796+1，我们要查找的 offset 为 368801 的 message 在该 index 内的偏移量为 368796+5&#x3D;368801，所以这里要查找的相对 offset 为 5）。由于该文件采用的是稀疏索引的方式存储着相对 offset 及对应 message 物理偏移量的关系，所以直接找相对 offset 为 5 的索引找不到，这里同样利用二分法查找相对 offset 小于或者等于指定的相对 offset 的索引条目中最大的那个相对 offset，所以找到的是相对 offset 为 4 的这个索引。</li><li>根据找到的相对 offset 为 4 的索引确定 message 存储的物理偏移位置为 256。打开数据文件，从位置为 256 的那个地方开始顺序扫描直到找到 offset 为 368801 的那条 Message。</li></ol><p>这套机制是建立在 offset 为有序的基础上，利用 segment + 有序 offset + 稀疏索引 + 二分查找 + 顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的 offset 维护 zookeeper 中，consumer 每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的 offset 已经直接维护在 kafk 集群的__consumer_offsets 这个 topic 中！</p>]]></content>
      
      
      <categories>
          
          <category> KafKa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KafKa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KafKa实战问题</title>
      <link href="/KafKa/KafKa%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98/"/>
      <url>/KafKa/KafKa%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h1><p>2024&#x2F;9&#x2F;23</p><p>消费者 逻辑 发生NPE导致–》 消费者不断重试消费—》发生消息积压—〉存在有的消息一直得不到消费</p><p>修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consume.exception.retry.count = 1 //表示失败后 重试消费1次</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cgshao02/BLOG_images/main/image-20240923140747749.png?token=A5BZ7JLVJDUYNCL5PKYCQY3G6EDAK"></p><h2 id="二、MQ“避坑”"><a href="#二、MQ“避坑”" class="headerlink" title="二、MQ“避坑”"></a>二、MQ“避坑”</h2><table><thead><tr><th>问题分类</th><th>消息积压</th></tr></thead><tbody><tr><td>相关描述</td><td>在使用MQ的过程中由于种种原因导致消息消费不及时造成消息积压</td></tr><tr><td>相关CASE</td><td></td></tr><tr><td>原因</td><td>1、消费流程卡死<br />2、 消息消费耗时过长  <br />3、消费组客户端启动失败 <br />4、消费线程过少，消费能力不够。 <br />5、客户端在消费失败后设置reture CONSUME_FAILURE，一旦不能恢复会导致一直重试</td></tr><tr><td>最佳实践</td><td>1、消费逻辑的业务处理尽量时间不要太长，如果存在长耗时逻辑尽量异步处理<br />2、不要过多和外系统进行交互，避免其他服务问题导致消费能力下降<br />3、消费线程要对异常进行分类处理，不要发生异常轻易终止或者关闭消费节点的注册<br />4、消息积压后，通过shovel可以应急处理，防止消息丢失<br />5、对与单Partition消息消费在不需要保证有序的情况下开启并行消费<br />6、发现问题及时扩容Partition并扩容消费者机器（注意消费者组的数量 和 Partition数量的权衡）<br />7、优化消费逻辑，能异步处理的尽量异步处理<br />8、消费失败不要使用CONSUME_FAILURE（导致消费重试）,可以使用RECONSUME_LATER，最后做好备份逻辑</td></tr></tbody></table><table><thead><tr><th>问题分类</th><th>消息丢失</th></tr></thead><tbody><tr><td>相关描述</td><td>在MQ使用过程由于MQ系统故障或者使用不当造成消息丢失</td></tr><tr><td>相关CASE</td><td></td></tr><tr><td>原因</td><td>1、mafka partition leader选举策略问题造成消息丢失。<br />2、 数据可靠性级别未设置为ack&#x3D;-1。 <br />3、在机器重启过程时，异步发送消息还没处理完客户端已经被销毁。 <br />4、消息过大造成发送失败 消息发送失败没有及时关注发送结果。<br />5、 集群机器大面积宕机 部分业务存在超时丢弃消息逻辑</td></tr><tr><td>最佳实践</td><td>1、业务消费未执行成功不要返回消费成功。 <br />2、程序退出先关闭Consumer和Producer。 <br />3、如果对消息丢失0容忍可设置客户端 ack&#x3D;-1。 <br />4、做好集群容灾处理，针对mafka尽量保证partition均匀分布在所有Broker中。 <br />5、不要发送超过1M以上消息</td></tr></tbody></table><table><thead><tr><th>问题分类</th><th>重复消费</th></tr></thead><tbody><tr><td>相关描述</td><td>在使用MQ过程中我们经常会遇到消息被重复消费问题，如果不能准确处理会导致线上问题</td></tr><tr><td>相关CASE</td><td></td></tr><tr><td>原因</td><td>1、绝大部分消息中间件均不能保证消息只被消费一次。 <br />2、生产者重复生产消息。</td></tr><tr><td>最佳实践</td><td>消息消费需要严格幂等控制，实现幂等的方式有很多，有依赖分布式锁将并行改成串行的、<br />也有依赖数据库的事务的、也有依赖与数据库记录的状态之间流转的状态机的；</td></tr></tbody></table><table><thead><tr><th>问题分类</th><th>消息发送失败</th></tr></thead><tbody><tr><td>相关描述</td><td>在使用MQ过程中会遇到使用不规范或者系统故障导致消息发送失败</td></tr><tr><td>相关CASE</td><td></td></tr><tr><td>原因</td><td>1、客户端是使用不规范，重复创建实例，造成大量系统资源消耗。<br />2、 系统异常未能及时监控流量，没有限流、切流预案。 <br />3、未处理发送结果</td></tr><tr><td>最佳实践</td><td>1、按照规范创建客户端，可采用Spring bean配置创建，保证一个消费组或生产者只有一个实例对象。<br />2、 关注发送结果。<br />3、 构建有效的流量监控应急预案。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> KafKa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KafKa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库慢查询</title>
      <link href="/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
      <url>/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、遇到的慢查询问题"><a href="#一、遇到的慢查询问题" class="headerlink" title="一、遇到的慢查询问题"></a>一、遇到的慢查询问题</h2><h3 id="1、表的索引区分度小导致的满查询"><a href="#1、表的索引区分度小导致的满查询" class="headerlink" title="1、表的索引区分度小导致的满查询"></a>1、表的索引区分度小导致的满查询</h3><p>为什么会命中不同的索引？</p><blockquote><p>索引的选择是优化器的工作，mysql的优化器选择索引时会极大的依赖“统计信息”。但是本质原因是原来的索引区分度很差</p></blockquote><h4 id="统计信息又是什么时候执行的？"><a href="#统计信息又是什么时候执行的？" class="headerlink" title="统计信息又是什么时候执行的？"></a>统计信息又是什么时候执行的？</h4><p>统计信息更新分为手动更新与自动更新。</p><p><strong>手动更新</strong></p><ol><li>ANALYZE table UPDATE HISTOGRAM ON <col_name> WITH <N> BUCKETS &#x2F;&#x2F;更新某个表的某个列的直方图</li><li>ANALYZE table DROP HISTOGRAM ON col_name &#x2F;&#x2F;删除某个表的直方图</li><li>ANALYZE table <table_name> &#x2F;&#x2F; 更新某个表中索引各个字段的cardinality</li></ol><p><strong>自动更新：</strong></p><ol><li>增删索引，加列， 清空表等涉及数据修改的DDL时；</li><li>后台线程发现表更新的记录超过表记录总数的1&#x2F;10时。</li></ol><h4 id="有触发过统计数据的日志吗？"><a href="#有触发过统计数据的日志吗？" class="headerlink" title="有触发过统计数据的日志吗？"></a>有触发过统计数据的日志吗？</h4><p>这是mysql的系统自发的行为，只能查看到最后一次更新的记录，没有历史日志。</p><p>DBA执行了analyze table后数据被覆盖了，忘记对analyze table命令前最后一次统计信息进行查看。</p><h4 id="这类满查询的注意事项"><a href="#这类满查询的注意事项" class="headerlink" title="这类满查询的注意事项"></a>这类满查询的注意事项</h4><p>（1）判断索引区分度的方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">column</span>) <span class="operator">/</span><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="comment">-- 索引区分度要大于70% --</span></span><br></pre></td></tr></table></figure><p>（2）设置降级策略、设置限流</p><p>（3）添加系统告警</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo踩坑纪录</title>
      <link href="/Hexo%E6%95%99%E7%A8%8B/hexo%E8%B8%A9%E5%9D%91%E7%BA%AA%E5%BD%95/"/>
      <url>/Hexo%E6%95%99%E7%A8%8B/hexo%E8%B8%A9%E5%9D%91%E7%BA%AA%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="点击页面跳转-变成了-下载lianje"><a href="#点击页面跳转-变成了-下载lianje" class="headerlink" title="点击页面跳转 变成了 下载lianje"></a>点击页面跳转 变成了 下载lianje</h2><p>查阅之后发现问题所在是在config配置文件中的</p><p>｜permalink: :title&#x2F;</p><p>少写了最后的&#x2F;，就会出现以上情况</p><p>同时如果少写了：，点击文章就会变成跳转到第一篇博文，跳转不了别的文章。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性：Stream流</title>
      <link href="/Java%E5%9F%BA%E7%A1%80/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream%E6%B5%81/"/>
      <url>/Java%E5%9F%BA%E7%A1%80/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 java 中，涉及到对数组、集合等集合类元素的操作时，通常我们使用的是循环的方式进行逐个遍历处理，或者使用 stream 流的方式进行处理。</p><h3 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h3><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作,流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 Stream（流）的组成包含:元素、数据源、聚合操作、内部迭代、Pipelining等。</p><h3 id="创建-Stream-流"><a href="#创建-Stream-流" class="headerlink" title="创建 Stream 流"></a>创建 Stream 流</h3><p>1）stream()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = stringList.stream();</span><br></pre></td></tr></table></figure><p>2）parallelStream()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = stringList.parallelStream();</span><br></pre></td></tr></table></figure><h3 id="Stream-流常用操作"><a href="#Stream-流常用操作" class="headerlink" title="Stream 流常用操作"></a>Stream 流常用操作</h3><p>1）forEach </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>2）map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream().map(i-&gt;i.equals(<span class="string">&quot;juejin&quot;</span>));</span><br></pre></td></tr></table></figure><p>3）filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream().filter(i-&gt;i.equals(<span class="string">&quot;juejin&quot;</span>));</span><br></pre></td></tr></table></figure><p>4）limit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>5）skip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().skip(<span class="number">5</span>).limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>6）distinct</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>7）sorted</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().sorted();</span><br></pre></td></tr></table></figure><p>8）sorted(Comparator com)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().sorted(Comparator.comparing(Integer::intValue));</span><br></pre></td></tr></table></figure><p>9）Collectors 收集器</p><p><img src="https://pic.yupi.icu/5563/202401242026474.png"></p><ul><li>恒等处理 Collectors</li></ul><p>所谓<strong>恒等处理</strong>，指的就是Stream的元素在经过Collector函数处理前后完全不变，例如toList()操作，只是最终将结果从Stream中取出放入到List对象中，并没有对元素本身做任何的更改处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(Collectors.toList());</span><br><span class="line">list.stream().collect(Collectors.toSet());</span><br><span class="line">list.stream().collect(Collectors.toCollection());</span><br></pre></td></tr></table></figure><ul><li>归约汇总 Collectors</li></ul><p>对于<strong>归约汇总</strong>类的操作，Stream流中的元素逐个遍历，进入到Collector处理函数中，然后会与上一个元素的处理结果进行合并处理，并得到一个新的结果，以此类推，直到遍历完成后，输出最终的结果</p><table><thead><tr><th>counting</th><th>统计流中的元素个数</th></tr></thead><tbody><tr><td>summingInt</td><td>计算流中指定int字段的累加总和。针对不同类型的数字类型，有不同的方法，比如summingDouble等</td></tr><tr><td>averagingInt</td><td>计算流中指定int字段的平均值。针对不同类型的数字类型，有不同的方法，比如averagingLong等</td></tr><tr><td>joining</td><td>将流中所有元素（或者元素的指定字段）字符串值进行拼接，可以指定拼接连接符，或者首尾拼接字符</td></tr><tr><td>maxBy</td><td>根据给定的比较器，选择出值最大的元素</td></tr><tr><td>minBy</td><td>根据给定的比较器，选择出值最小的元素</td></tr></tbody></table><ul><li><p>分组分区 Collectors</p></li><li><ul><li>仅仅是做一个常规的数据分组操作时，可以仅传入一个分组函数即可</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">groupBySubCompany</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 按照子公司维度将员工分组</span></span><br><span class="line">    Map&lt;String, List&lt;Employee&gt;&gt; resultMap =</span><br><span class="line">            getAllEmployees().stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getSubCompany));</span><br><span class="line">    System.out.println(resultMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>如果不仅需要分组，还需要对分组后的数据进行处理的时候，则需要同时给定分组函数以及值收集器</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">groupAndCaculate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 按照子公司分组，并统计每个子公司的员工数</span></span><br><span class="line">    Map&lt;String, Long&gt; resultMap = getAllEmployees().stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getSubCompany,</span><br><span class="line">                    Collectors.counting()));</span><br><span class="line">    System.out.println(resultMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。让程序员写出高效率、干净、简洁的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
