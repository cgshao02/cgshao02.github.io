<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>草稿</title>
      <link href="/uncategorized/%E8%8D%89%E7%A8%BF"/>
      <url>/uncategorized/%E8%8D%89%E7%A8%BF</url>
      
        <content type="html"><![CDATA[<h2 id="这是一篇草稿，测试草稿信息"><a href="#这是一篇草稿，测试草稿信息" class="headerlink" title="这是一篇草稿，测试草稿信息"></a>这是一篇草稿，测试草稿信息</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性：Stream流</title>
      <link href="/uncategorized/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream%E6%B5%81"/>
      <url>/uncategorized/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream%E6%B5%81</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 java 中，涉及到对数组、集合等集合类元素的操作时，通常我们使用的是循环的方式进行逐个遍历处理，或者使用 stream 流的方式进行处理。</p><h3 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h3><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作,流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 Stream（流）的组成包含:元素、数据源、聚合操作、内部迭代、Pipelining等。</p><h3 id="创建-Stream-流"><a href="#创建-Stream-流" class="headerlink" title="创建 Stream 流"></a>创建 Stream 流</h3><p>1）stream()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = stringList.stream();</span><br></pre></td></tr></table></figure><p>2）parallelStream()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = stringList.parallelStream();</span><br></pre></td></tr></table></figure><h3 id="Stream-流常用操作"><a href="#Stream-流常用操作" class="headerlink" title="Stream 流常用操作"></a>Stream 流常用操作</h3><p>1）forEach </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>2）map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream().map(i-&gt;i.equals(<span class="string">&quot;juejin&quot;</span>));</span><br></pre></td></tr></table></figure><p>3）filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream().filter(i-&gt;i.equals(<span class="string">&quot;juejin&quot;</span>));</span><br></pre></td></tr></table></figure><p>4）limit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>5）skip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().skip(<span class="number">5</span>).limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>6）distinct</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>7）sorted</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().sorted();</span><br></pre></td></tr></table></figure><p>8）sorted(Comparator com)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().sorted(Comparator.comparing(Integer::intValue));</span><br></pre></td></tr></table></figure><p>9）Collectors 收集器</p><p><img src="https://pic.yupi.icu/5563/202401242026474.png"></p><ul><li>恒等处理 Collectors</li></ul><p>所谓<strong>恒等处理</strong>，指的就是Stream的元素在经过Collector函数处理前后完全不变，例如toList()操作，只是最终将结果从Stream中取出放入到List对象中，并没有对元素本身做任何的更改处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(Collectors.toList());</span><br><span class="line">list.stream().collect(Collectors.toSet());</span><br><span class="line">list.stream().collect(Collectors.toCollection());</span><br></pre></td></tr></table></figure><ul><li>归约汇总 Collectors</li></ul><p>对于<strong>归约汇总</strong>类的操作，Stream流中的元素逐个遍历，进入到Collector处理函数中，然后会与上一个元素的处理结果进行合并处理，并得到一个新的结果，以此类推，直到遍历完成后，输出最终的结果</p><table><thead><tr><th>counting</th><th>统计流中的元素个数</th></tr></thead><tbody><tr><td>summingInt</td><td>计算流中指定int字段的累加总和。针对不同类型的数字类型，有不同的方法，比如summingDouble等</td></tr><tr><td>averagingInt</td><td>计算流中指定int字段的平均值。针对不同类型的数字类型，有不同的方法，比如averagingLong等</td></tr><tr><td>joining</td><td>将流中所有元素（或者元素的指定字段）字符串值进行拼接，可以指定拼接连接符，或者首尾拼接字符</td></tr><tr><td>maxBy</td><td>根据给定的比较器，选择出值最大的元素</td></tr><tr><td>minBy</td><td>根据给定的比较器，选择出值最小的元素</td></tr></tbody></table><ul><li><p>分组分区 Collectors</p></li><li><ul><li>仅仅是做一个常规的数据分组操作时，可以仅传入一个分组函数即可</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">groupBySubCompany</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 按照子公司维度将员工分组</span></span><br><span class="line">    Map&lt;String, List&lt;Employee&gt;&gt; resultMap =</span><br><span class="line">            getAllEmployees().stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getSubCompany));</span><br><span class="line">    System.out.println(resultMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>如果不仅需要分组，还需要对分组后的数据进行处理的时候，则需要同时给定分组函数以及值收集器</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">groupAndCaculate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 按照子公司分组，并统计每个子公司的员工数</span></span><br><span class="line">    Map&lt;String, Long&gt; resultMap = getAllEmployees().stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getSubCompany,</span><br><span class="line">                    Collectors.counting()));</span><br><span class="line">    System.out.println(resultMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。让程序员写出高效率、干净、简洁的代码。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
