<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库慢查询</title>
      <link href="/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%BB%A1%E6%9F%A5%E8%AF%A2/"/>
      <url>/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%BB%A1%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、遇到的慢查询问题"><a href="#一、遇到的慢查询问题" class="headerlink" title="一、遇到的慢查询问题"></a>一、遇到的慢查询问题</h2><h3 id="1、表的索引区分度小导致的满查询"><a href="#1、表的索引区分度小导致的满查询" class="headerlink" title="1、表的索引区分度小导致的满查询"></a>1、表的索引区分度小导致的满查询</h3><p>为什么会命中不同的索引？</p><blockquote><p>索引的选择是优化器的工作，mysql的优化器选择索引时会极大的依赖“统计信息”。但是本质原因是原来的索引区分度很差</p></blockquote><h4 id="统计信息又是什么时候执行的？"><a href="#统计信息又是什么时候执行的？" class="headerlink" title="统计信息又是什么时候执行的？"></a>统计信息又是什么时候执行的？</h4><p>统计信息更新分为手动更新与自动更新。</p><p><strong>手动更新</strong></p><ol><li>ANALYZE table UPDATE HISTOGRAM ON <col_name> WITH <N> BUCKETS &#x2F;&#x2F;更新某个表的某个列的直方图</li><li>ANALYZE table DROP HISTOGRAM ON col_name &#x2F;&#x2F;删除某个表的直方图</li><li>ANALYZE table <table_name> &#x2F;&#x2F; 更新某个表中索引各个字段的cardinality</li></ol><p><strong>自动更新：</strong></p><ol><li>增删索引，加列， 清空表等涉及数据修改的DDL时；</li><li>后台线程发现表更新的记录超过表记录总数的1&#x2F;10时。</li></ol><h4 id="有触发过统计数据的日志吗？"><a href="#有触发过统计数据的日志吗？" class="headerlink" title="有触发过统计数据的日志吗？"></a>有触发过统计数据的日志吗？</h4><p>这是mysql的系统自发的行为，只能查看到最后一次更新的记录，没有历史日志。</p><p>DBA执行了analyze table后数据被覆盖了，忘记对analyze table命令前最后一次统计信息进行查看。</p><h4 id="这类满查询的注意事项"><a href="#这类满查询的注意事项" class="headerlink" title="这类满查询的注意事项"></a>这类满查询的注意事项</h4><p>（1）判断索引区分度的方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">column</span>) <span class="operator">/</span><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="comment">-- 索引区分度要大于70% --</span></span><br></pre></td></tr></table></figure><p>（2）设置降级策略、设置限流</p><p>（3）添加系统告警</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo踩坑纪录</title>
      <link href="/Hexo%E6%95%99%E7%A8%8B/hexo%E8%B8%A9%E5%9D%91%E7%BA%AA%E5%BD%95/"/>
      <url>/Hexo%E6%95%99%E7%A8%8B/hexo%E8%B8%A9%E5%9D%91%E7%BA%AA%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="点击页面跳转-变成了-下载lianje"><a href="#点击页面跳转-变成了-下载lianje" class="headerlink" title="点击页面跳转 变成了 下载lianje"></a>点击页面跳转 变成了 下载lianje</h2><p>查阅之后发现问题所在是在config配置文件中的</p><p>｜permalink: :title&#x2F;</p><p>少写了最后的&#x2F;，就会出现以上情况</p><p>同时如果少写了：，点击文章就会变成跳转到第一篇博文，跳转不了别的文章。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性：Stream流</title>
      <link href="/Java%E5%9F%BA%E7%A1%80/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream%E6%B5%81/"/>
      <url>/Java%E5%9F%BA%E7%A1%80/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 java 中，涉及到对数组、集合等集合类元素的操作时，通常我们使用的是循环的方式进行逐个遍历处理，或者使用 stream 流的方式进行处理。</p><h3 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h3><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作,流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 Stream（流）的组成包含:元素、数据源、聚合操作、内部迭代、Pipelining等。</p><h3 id="创建-Stream-流"><a href="#创建-Stream-流" class="headerlink" title="创建 Stream 流"></a>创建 Stream 流</h3><p>1）stream()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = stringList.stream();</span><br></pre></td></tr></table></figure><p>2）parallelStream()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = stringList.parallelStream();</span><br></pre></td></tr></table></figure><h3 id="Stream-流常用操作"><a href="#Stream-流常用操作" class="headerlink" title="Stream 流常用操作"></a>Stream 流常用操作</h3><p>1）forEach </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>2）map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream().map(i-&gt;i.equals(<span class="string">&quot;juejin&quot;</span>));</span><br></pre></td></tr></table></figure><p>3）filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream().filter(i-&gt;i.equals(<span class="string">&quot;juejin&quot;</span>));</span><br></pre></td></tr></table></figure><p>4）limit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>5）skip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().skip(<span class="number">5</span>).limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>6）distinct</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>7）sorted</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().sorted();</span><br></pre></td></tr></table></figure><p>8）sorted(Comparator com)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integerList.stream().sorted(Comparator.comparing(Integer::intValue));</span><br></pre></td></tr></table></figure><p>9）Collectors 收集器</p><p><img src="https://pic.yupi.icu/5563/202401242026474.png"></p><ul><li>恒等处理 Collectors</li></ul><p>所谓<strong>恒等处理</strong>，指的就是Stream的元素在经过Collector函数处理前后完全不变，例如toList()操作，只是最终将结果从Stream中取出放入到List对象中，并没有对元素本身做任何的更改处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(Collectors.toList());</span><br><span class="line">list.stream().collect(Collectors.toSet());</span><br><span class="line">list.stream().collect(Collectors.toCollection());</span><br></pre></td></tr></table></figure><ul><li>归约汇总 Collectors</li></ul><p>对于<strong>归约汇总</strong>类的操作，Stream流中的元素逐个遍历，进入到Collector处理函数中，然后会与上一个元素的处理结果进行合并处理，并得到一个新的结果，以此类推，直到遍历完成后，输出最终的结果</p><table><thead><tr><th>counting</th><th>统计流中的元素个数</th></tr></thead><tbody><tr><td>summingInt</td><td>计算流中指定int字段的累加总和。针对不同类型的数字类型，有不同的方法，比如summingDouble等</td></tr><tr><td>averagingInt</td><td>计算流中指定int字段的平均值。针对不同类型的数字类型，有不同的方法，比如averagingLong等</td></tr><tr><td>joining</td><td>将流中所有元素（或者元素的指定字段）字符串值进行拼接，可以指定拼接连接符，或者首尾拼接字符</td></tr><tr><td>maxBy</td><td>根据给定的比较器，选择出值最大的元素</td></tr><tr><td>minBy</td><td>根据给定的比较器，选择出值最小的元素</td></tr></tbody></table><ul><li><p>分组分区 Collectors</p></li><li><ul><li>仅仅是做一个常规的数据分组操作时，可以仅传入一个分组函数即可</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">groupBySubCompany</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 按照子公司维度将员工分组</span></span><br><span class="line">    Map&lt;String, List&lt;Employee&gt;&gt; resultMap =</span><br><span class="line">            getAllEmployees().stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getSubCompany));</span><br><span class="line">    System.out.println(resultMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>如果不仅需要分组，还需要对分组后的数据进行处理的时候，则需要同时给定分组函数以及值收集器</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">groupAndCaculate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 按照子公司分组，并统计每个子公司的员工数</span></span><br><span class="line">    Map&lt;String, Long&gt; resultMap = getAllEmployees().stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getSubCompany,</span><br><span class="line">                    Collectors.counting()));</span><br><span class="line">    System.out.println(resultMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。让程序员写出高效率、干净、简洁的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
